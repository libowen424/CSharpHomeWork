<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="origin" />
    <meta property="og:description" content="什么是spring security? spring security是基于spring的安全框架.它提供全面的安全性解决方案,同时在Web请求级别和调用级别确认和授权.在Spring Framewo" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>基于spring的安全管理框架-Spring Security - 蚂蚁style - 博客园</title>
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=-oFz8B4m7JhHaZzdTkzPza2oLZNDRR8obnCz6w7OHbU" />
    <link id="MainCss" rel="stylesheet" href="/skins/coffee/bundle-coffee.min.css?v=pdMIVgsH8kXt-vOWnlL0N20TlHt3UyP9HzGgocfsP4s" />
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/coffee/bundle-coffee-mobile.min.css?v=na9bpAY4yh7uEWCcrXj3vfJM3VBse8YtU6-5fUUQPz0" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/zhaoletian/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/zhaoletian/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/zhaoletian/wlwmanifest.xml" />
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=z6JkvKQ7L_bGD-nwJExYzsoFf5qnluqZJru6RsfoZuM"></script>
    <script>
        var currentBlogId = 503265;
        var currentBlogApp = 'zhaoletian';
        var cb_enable_mathjax = false;
        var isLogined = false;
        var skinName = 'coffee';
    </script>
    
    
    
</head>
<body>
    <a name="top"></a>
    
    
<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
	<a href="https://www.cnblogs.com/zhaoletian/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>			
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/zhaoletian/">蚂蚁style</a>
</h1>
<h2>

</h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="navigator">
			
<ul id="navList">
	<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
	<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/zhaoletian/">
首页</a>
</li>
	<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
	<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/%E8%9A%82%E8%9A%81style">
联系</a></li>
	<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
	<li>
<a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/zhaoletian/rss/">
订阅</a>
	
<a id="blog_nav_rss_image" href="https://www.cnblogs.com/zhaoletian/rss/">
    <img src="/skins/coffee/images/xml.gif" alt="订阅" />
</a></li>
</ul>



			<div class="blogStats">
				
				<!--done-->
随笔- 
20&nbsp;
文章- 
3&nbsp;
评论- 
0&nbsp;



				
			</div><!--end: blogStats -->
		</div><!--end: navigator 博客导航栏 -->
		<div id="post_detail">
<!--done-->
<div id="topics">
	<div class="post">
		<h1 class = "postTitle">
			
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/zhaoletian/p/12747628.html">基于spring的安全管理框架-Spring Security</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			
<div id="cnblogs_post_body" class="blogpost-body ">
    <h2>什么是spring security?</h2>
<p>　　spring security是基于spring的安全框架.它提供全面的安全性解决方案,同时在Web请求级别和调用级别确认和授权.在Spring Framework基础上,spring security充分利用了依赖注入(DI)和面向切面编程(AOP)功能,为应用系统提供声明式的安全访问控制功能,建晒了为企业安全控制编写大量重复代码的工作,是一个轻量级的安全框架,并且很好集成Spring MVC</p>
<h2>spring security的核心功能有哪些?</h2>
<p>　　1 认证 :认证用户</p>
<p>　　2 验证: 验证用户是否有哪些权限,可以做哪些事情</p>
<h2>spring security基于哪些技术实现?</h2>
<p>　　　　Filter,Servlet,AOP实现</p>
<h3>框架技术准备:</h3>
<p>　　IDEA 2017.3 ,MAVEN 3+ ,springboot 2.2.6 spring security 5.2.2, JDK 8+</p>
<p>&nbsp;</p>
<h2>spring security初步集成使用</h2>
<p>创建一个基于Maven的spring boot项目,引入必需依赖</p>
<p>父级依赖</p>
<div class="cnblogs_code">
<pre> &lt;parent&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-parent&lt;/artifactId&gt;
      &lt;version&gt;<span style="color: #800080;">2.2.<span style="color: #800080;">6.RELEASE&lt;/version&gt;
  &lt;/parent&gt;</span></span></pre>
</div>
<p>springboot项目集成spring security的起步依赖</p>
<p>springboot web项目的起步依赖</p>
<div class="cnblogs_code">
<pre> &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;</pre>
</div>
<p>我们启动springboot项目的主类</p>
<p><img src="https://img2020.cnblogs.com/blog/1639414/202004/1639414-20200421203238046-1639866919.png" alt="" width="821" height="195"></p>
<p>&nbsp;大家可以看到,此刻我们已经实现了spring security最简单的功能,上面截图的最下方就是spring sceurity给我们随机生成的密码</p>
<p>我们此刻可以创建一个最简单的controller层来测试访问安全控制</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">@RestController
<span style="color: #0000ff;">public <span style="color: #0000ff;">class<span style="color: #000000;"> HelloController {

    @RequestMapping(<span style="color: #800000;">"<span style="color: #800000;">/sayHello<span style="color: #800000;">"<span style="color: #000000;">)
    <span style="color: #0000ff;">public<span style="color: #000000;"> String sayHello() {
        System.<span style="color: #0000ff;">out.println(<span style="color: #800000;">"<span style="color: #800000;">Hello,spring security<span style="color: #800000;">"<span style="color: #000000;">);
        <span style="color: #0000ff;">return <span style="color: #800000;">"<span style="color: #800000;">hello,spring security<span style="color: #800000;">"<span style="color: #000000;">;
    }

}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
</div>
<p>接下来我们通过调用这个sayHello接口,我们会得到一个登录界面</p>
<p>此刻我们输入默认的用户名user ,密码就是控制台随机生成的一串字符 2dddf218-48c7-454c-875d-f7283e8457c1</p>
<p>我们就可以以成功访问:&nbsp; <span style="color: #6a8759;">hello,spring security <br /></span></p>
<p>当然,我们也可以在spring的配置文件中去配置自定义的用户名和密码,这样也可以实现同样的效果,配置如下图所示.</p>
<p><img src="https://img2020.cnblogs.com/blog/1639414/202004/1639414-20200422164024188-1289384897.png" alt=""></p>
<p>&nbsp;<img src="https://img2020.cnblogs.com/blog/1639414/202004/1639414-20200422164317745-1823641728.png" alt=""></p>
<p>如果我们不想使用spring security的访问控制功能,我们可以在Springboot的启动类注解上排除spring security的自动配置</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre>@SpringBootApplication(exclude ={SecurityAutoConfiguration.<span style="color: #0000ff;">class})</span></pre>
</div>
<p>&nbsp;</p>
<p>这样我们再次访问接口,就不会要求我们登陆就可以直接访问了.</p>
<h2>Spring Security 基于内存配置:</h2>
<p>去除上述所有配置,我们重新配置一个配置类去继承WebSecurityConfigurerAdapter,这个适配器类有很多方法,我们需要重写configure(AuthenticationManagerBuilder auth)方法</p>
<div class="cnblogs_code">
<pre>@Configuration <span style="color: #008000;">//</span><span style="color: #008000;">配置类</span>
@EnableWebSecurity <span style="color: #008000;">//</span><span style="color: #008000;">启用spring security安全框架功能</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MyWebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    </span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> configure(AuthenticationManagerBuilder auth) throws Exception {
        PasswordEncoder passwordEncoder </span>=<span style="color: #000000;"> passwordEncoder();
        auth.inMemoryAuthentication().withUser(</span><span style="color: #800000;">"</span><span style="color: #800000;">admin</span><span style="color: #800000;">"</span>).password(passwordEncoder.encode(<span style="color: #800000;">"</span><span style="color: #800000;">123456</span><span style="color: #800000;">"</span><span style="color: #000000;">))
                .roles(</span><span style="color: #000000;">);</span><span style="color: #000000;">
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">*
     * spring security自带的加密算法PasswordEncoder,我们使用其中一种算法来对密码加密 BCryptPasswordEncoder方法采用SHA-256
     * +随机盐+密钥对密码进行加密,过程不可逆 不加密高版本会报错
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    @Bean
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> PasswordEncoder passwordEncoder() {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> BCryptPasswordEncoder();
    }
}</span></pre>
</div>
<p>&nbsp;这样我们就在内存配置了用户admin,密码采用加密算法去实现内存中的用户登录认证.</p>
<p>在实际的场景中一个用户可能有多个角色,接下来看一下基于内存角色的用户认证</p>
<p>&nbsp;首先我们在配置类上需要添加注解启用方法级别的用户角色认证<span style="color: #bbb529;">@EnableGlobalMethodSecurity(<span style="color: #d0d0ff;">prePostEnabled = <span style="color: #cc7832;">true)</span></span></span></p>
<div class="cnblogs_code">
<pre>@Configuration <span style="color: #008000;">//</span><span style="color: #008000;">配置类</span>
@EnableWebSecurity <span style="color: #008000;">//</span><span style="color: #008000;">启用spring security安全框架功能</span>
@EnableGlobalMethodSecurity(prePostEnabled = <span style="color: #0000ff;">true</span><span style="color: #000000;">)
</span><span style="color: #008000;">//</span><span style="color: #008000;">启用方法级别的认证 prePostEnabled boolean默认false,true表示可以使用 @PreAuthorize注解 和 @PostAuthorize注解</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MyWebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    </span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> configure(AuthenticationManagerBuilder auth) throws Exception {
        PasswordEncoder passwordEncoder </span>=<span style="color: #000000;"> passwordEncoder();
        auth.inMemoryAuthentication().withUser(</span><span style="color: #800000;">"</span><span style="color: #800000;">admin</span><span style="color: #800000;">"</span>).password(passwordEncoder.encode(<span style="color: #800000;">"</span><span style="color: #800000;">123456</span><span style="color: #800000;">"</span><span style="color: #000000;">))
                .roles(</span><span style="color: #800000;">"</span><span style="color: #800000;">super</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">normal</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        auth.inMemoryAuthentication().withUser(</span><span style="color: #800000;">"</span><span style="color: #800000;">normal</span><span style="color: #800000;">"</span>).password(passwordEncoder.encode(<span style="color: #800000;">"</span><span style="color: #800000;">123456</span><span style="color: #800000;">"</span><span style="color: #000000;">))
                .roles(</span><span style="color: #800000;">"</span><span style="color: #800000;">normal</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">*
     * spring security自带的加密算法PasswordEncoder,我们使用其中一种算法来对密码加密 BCryptPasswordEncoder方法采用SHA-256
     * +随机盐+密钥对密码进行加密,过程不可逆 不加密高版本会报错
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    @Bean
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> PasswordEncoder passwordEncoder() {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> BCryptPasswordEncoder();
    }
}</span></pre>
</div>
<p>&nbsp;此刻我们在内存中创建了两个用户,一个normal用户,只有normal权限,一个admin用户,拥有super权限和normal权限.</p>
<p>我们创建三个访问路径,分别对应super,normal和 super,normal都可以访问</p>
<div class="cnblogs_code">
<pre>    @RequestMapping(<span style="color: #800000;">"</span><span style="color: #800000;">/super</span><span style="color: #800000;">"</span><span style="color: #000000;">)
    @PreAuthorize(value </span>= <span style="color: #800000;">"</span><span style="color: #800000;">hasRole('super')</span><span style="color: #800000;">"</span><span style="color: #000000;">)
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String saySuper() {
        System.</span><span style="color: #0000ff;">out</span>.println(<span style="color: #800000;">"</span><span style="color: #800000;">Hello,super!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">Hello,super</span><span style="color: #800000;">"</span><span style="color: #000000;">;
    }

    @RequestMapping(</span><span style="color: #800000;">"</span><span style="color: #800000;">/normal</span><span style="color: #800000;">"</span><span style="color: #000000;">)
    @PreAuthorize(value </span>= <span style="color: #800000;">"</span><span style="color: #800000;">hasRole('normal')</span><span style="color: #800000;">"</span><span style="color: #000000;">)
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String sayNormal() {
        System.</span><span style="color: #0000ff;">out</span>.println(<span style="color: #800000;">"</span><span style="color: #800000;">Hello,normal!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">hello,normal</span><span style="color: #800000;">"</span><span style="color: #000000;">;
    }

    @RequestMapping(</span><span style="color: #800000;">"</span><span style="color: #800000;">/all</span><span style="color: #800000;">"</span><span style="color: #000000;">)
    @PreAuthorize(value </span>= <span style="color: #800000;">"</span><span style="color: #800000;">hasAnyRole('normal','super')</span><span style="color: #800000;">"</span><span style="color: #000000;">)
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String sayAll() {
        System.</span><span style="color: #0000ff;">out</span>.println(<span style="color: #800000;">"</span><span style="color: #800000;">Hello,super,normal!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">Hello,super,normal</span><span style="color: #800000;">"</span><span style="color: #000000;">;
    }</span></pre>
</div>
<p><span style="color: #bbb529;">&nbsp;我们会发现,normal用户可以访问2,3 admin可以访问 1,2,3,由此可以看出,此刻权限控制是OK的<br /></span></p>
<p>&nbsp;这样简单地基于内存的用户权限认证就完成了,但是内存中的用户信息是不稳定不可靠的,我们需要从数据库读取,那么spring security又是如何帮我们去完成的呢?</p>
<h2>spring security基于数据库用户信息的安全访问控制</h2>
<p>&nbsp;当我们把用户信息加入到数据库,需要实现框架提供的UserDetailsService接口,去通过调用数据库去获取我们需要的用户和角色信息</p>
<div class="cnblogs_code">
<pre>@Configuration <span style="color: #008000;">//</span><span style="color: #008000;">配置类</span>
@EnableWebSecurity <span style="color: #008000;">//</span><span style="color: #008000;">启用spring security安全框架功能</span>
@EnableGlobalMethodSecurity(prePostEnabled = <span style="color: #0000ff;">true</span><span style="color: #000000;">)
</span><span style="color: #008000;">//</span><span style="color: #008000;">启用方法级别的认证 prePostEnabled boolean默认false,true表示可以使用 @PreAuthorize注解 和 @PostAuthorize注解</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MyWebSecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> MyUserDetailService userDetailService;
    @Override
    </span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> configure(AuthenticationManagerBuilder auth) throws Exception {
        PasswordEncoder passwordEncoder </span>=<span style="color: #000000;"> passwordEncoder();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">        auth.inMemoryAuthentication().withUser("admin").password(passwordEncoder.encode("123456"))
        </span><span style="color: #008000;">//</span><span style="color: #008000;">                .roles("super", "normal");</span>
        auth.userDetailsService(userDetailService).passwordEncoder(<span style="color: #0000ff;">new</span><span style="color: #000000;"> BCryptPasswordEncoder());
    }
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">*
     * spring security自带的加密算法PasswordEncoder,我们使用其中一种算法来对密码加密 BCryptPasswordEncoder方法采用SHA-256
     * +随机盐+密钥对密码进行加密,过程不可逆 不加密高版本会报错
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    @Bean
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> PasswordEncoder passwordEncoder() {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> BCryptPasswordEncoder();
    }
}</span></pre>
</div>
<p>自定义实现的接口,去通过数据库查询用户信息,此处需要注意两个地方,</p>
<p><span style="background-color: #ffffff; color: #3366ff;">1:我们数据库的密码是通过new BCryptPasswordEncoder().encode("123456")生成的,明文密码是不可以的,因为我们已经指定了密码加密规则BCryptPasswordEncoder,</span></p>
<p><span style="color: #3366ff; background-color: #ffffff;">2:我们若有多个角色怎么办?循环遍历放入list中,注意:角色必须以ROLE_开头</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">@Component
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MyUserDetailService implements UserDetailsService {

    @Resource
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> UserMapper userMapper;

    @Override
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> UserDetails loadUserByUsername(String userName) throws UsernameNotFoundException {
        org.springframework.security.core.userdetails.User user </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        User userInfo </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">StringUtils.isEmpty(userName)) {
            userInfo </span>=<span style="color: #000000;"> userMapper.getUserInfoByName(userName);
            </span><span style="color: #0000ff;">if</span> (userInfo != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                List</span>&lt;GrantedAuthority&gt; list = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();
                String role </span>=<span style="color: #000000;"> userInfo.getRole();
                GrantedAuthority authority </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> SimpleGrantedAuthority(
                        </span><span style="color: #800000;">"</span><span style="color: #800000;">ROLE_</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> userInfo.getRole());
                list.add(authority);
                </span><span style="color: #008000;">//</span><span style="color: #008000;">创建User对象返回</span>
                user = <span style="color: #0000ff;">new</span><span style="color: #000000;"> org.springframework.security.core.userdetails.User(userInfo.getName(),
                        userInfo.getPassword(), list);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> user;
    }
}</span></pre>
</div>
<p>这里的接口给予了用户极大的扩展空间,我们最终创建User对象返回,User对象有两个构造方法,根据需要选取,参数含义参考源码对照就行</p>
<p><img src="https://img2020.cnblogs.com/blog/1639414/202004/1639414-20200424105706469-1881145709.png" alt="">　</p>
<p>&nbsp;这样我们就通过查询数据库获取用户的登录用户名和密码以及角色信息是否匹配和具有访问权限.</p>
<h2>基于角色的权限</h2>
<p>　　认证和授权:</p>
<p>　　认证(authentication):认证访问者是谁?是否是当前系统的有限用户</p>
<p>　　授权(authorization):当前用户可以做什么?</p>
<p>我们就以RBAC(Role-Based Access controll),这样我们就需要设计出最少五张表去完成权限控制</p>
<p>user 表(存储用户信息)</p>
<p>user_role(用户角色信息关系表)</p>
<p>role表(角色信息)</p>
<p>role_permission(角色权限信息关系表)</p>
<p>permission(授权信息,可以存储访问url路径等)&nbsp;&nbsp;</p>
<p><img src="https://img2020.cnblogs.com/blog/1639414/202004/1639414-20200424140823339-1498940304.png" alt="" width="368" height="80"></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;这样的权限设计模型,权限授予角色,角色授予用户,管理起来清晰明了</p>
<p>接下来我们需要再次重写MyWebSecurityConfig中的两个configure方法</p>
<p><img src="https://img2020.cnblogs.com/blog/1639414/202004/1639414-20200424150656309-1115738812.png" alt=""></p>
<p>&nbsp;我们如果想忽略控制某些资源,不加访问拦截,我们就可以在WebSecurity方法配置忽略请求的url,一般会设置登录路径,获取图形验证码路径,静态资源等</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;"> @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> configure(WebSecurity web) throws Exception {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">设置忽略拦截的路径匹配,这些请求无需拦截,直接放行</span>
        web.ignoring().antMatchers(<span style="color: #800000;">"</span><span style="color: #800000;">/index.html</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">/static/**</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">/login_p</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">/getPicture</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    }</span></pre>
</div>
<p>接下来我们就重点讲一下重新的下一个方法HttpSecurity,这个方法里面配置了我们对于权限的处理</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;"> @Override
    </span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> configure(HttpSecurity http) throws Exception {
        http.authorizeRequests() </span><span style="color: #008000;">//</span><span style="color: #008000;">authorizeRequests() 允许基于使用HttpServletRequest限制访问</span>
                .withObjectPostProcessor(postProcessor())  <span style="color: #008000;">//</span><span style="color: #008000;">请求都会经过此方法配置的过滤器*****重点******,出了WebSecurity配置的忽略请求</span>
                .and()  <span style="color: #008000;">//</span><span style="color: #008000;">返回HttpSecurity对象-----------------------------------</span>
                .formLogin()  <span style="color: #008000;">//</span><span style="color: #008000;">指定基于表单的身份验证没指定,则将生成默认登录页面</span>
                .loginPage(<span style="color: #800000;">"</span><span style="color: #800000;">/login_p</span><span style="color: #800000;">"</span>) <span style="color: #008000;">//</span><span style="color: #008000;">指定跳转登录页</span>
                .loginProcessingUrl(<span style="color: #800000;">"</span><span style="color: #800000;">/login</span><span style="color: #800000;">"</span>) <span style="color: #008000;">//</span><span style="color: #008000;">登录路径</span>
                .usernameParameter(<span style="color: #800000;">"</span><span style="color: #800000;">username</span><span style="color: #800000;">"</span>) <span style="color: #008000;">//</span><span style="color: #008000;">用户名参数名</span>
                .passwordParameter(<span style="color: #800000;">"</span><span style="color: #800000;">password</span><span style="color: #800000;">"</span>)<span style="color: #008000;">//</span><span style="color: #008000;">密码参数名</span>
                .failureHandler(customAuthenticationFailureHandler()) <span style="color: #008000;">//</span><span style="color: #008000;">自定义失败处理</span>
                .successHandler(customAuthenticationSuccessHandler()) <span style="color: #008000;">//</span><span style="color: #008000;">自定义成功处理</span>
                .permitAll().and() <span style="color: #008000;">//</span><span style="color: #008000;">返回HttpSecurity对象----------------------------------------</span>
                .logout()<span style="color: #008000;">//
</span>                .logoutUrl(<span style="color: #800000;">"</span><span style="color: #800000;">/logout</span><span style="color: #800000;">"</span><span style="color: #000000;">).logoutSuccessHandler(customLogoutSuccessHandler())
                .permitAll()</span><span style="color: #008000;">//
</span>                .and()  <span style="color: #008000;">//</span><span style="color: #008000;">返回HttpSecurity对象----------------------------------------</span>
                .csrf().disable() <span style="color: #008000;">//</span><span style="color: #008000;">默认会开启CSRF处理，判断请求是否携带了token，如果没有就拒绝访问  我们此处设置禁用</span>
                .exceptionHandling()<span style="color: #008000;">//
</span>                .authenticationEntryPoint(customAuthenticationEntryPoint()) <span style="color: #008000;">//</span><span style="color: #008000;">认证入口</span>
                .accessDeniedHandler(customAccessDeniedHandler()); <span style="color: #008000;">//</span><span style="color: #008000;">访问拒绝处理</span>
    }</pre>
</div>
<div class="cnblogs_code">
<pre> <span style="color: #0000ff;">public</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;<span style="color: #000000;"> postProcessor() {
        ObjectPostProcessor</span>&lt;FilterSecurityInterceptor&gt; obj = <span style="color: #0000ff;">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() { <span style="color: #008000;">//</span><span style="color: #008000;">此方法</span>
<span style="color: #000000;">            @Override
            </span><span style="color: #0000ff;">public</span> &lt;O extends FilterSecurityInterceptor&gt; O postProcess(O <span style="color: #0000ff;">object</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">object</span>.setSecurityMetadataSource(metadataSource); <span style="color: #008000;">//</span><span style="color: #008000;">通过请求地址获取改地址需要的用户角色</span>
                <span style="color: #0000ff;">object</span><span style="color: #000000;">.setAccessDecisionManager(
                        accessDecisionManager); </span><span style="color: #008000;">//</span><span style="color: #008000;">判断是否登录,是否当前用户是否具有访问当前url的角色</span>
                <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">object</span><span style="color: #000000;">;
            }
        };
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> obj;
    }</span></pre>
</div>
<p>在这里我们需要实现两个接口FilterInvocationSecurityMetadataSource ,AccessDecisionManager</p>
<p>首先是FilterInvocationSecurityMetadataSource,我们在这个接口实现类里面<span style="color: #000000;">getAttributes()方法主要做的就是获取请求路径url,然后去数据库查询哪些角色具有此路径的访问权限,然后把角色信息返回List&lt;ConfigAttribute&gt;,很巧,SecurityConfig已经提供了一个方法createList,我们直接调用此方法返回就可以</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">@Component
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CustomMetadataSource implements FilterInvocationSecurityMetadataSource {

    @Override
    </span><span style="color: #0000ff;">public</span> Collection&lt;ConfigAttribute&gt;<span style="color: #000000;"> getAttributes(Object o) throws IllegalArgumentException {<br />　　　　String requestUrl = ((FilterInvocation)o).getRequestUrl();
        List</span>&lt;String&gt; list = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ArrayList();
        </span><span style="color: #0000ff;">if</span> (list.size() &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {<br />　　　　//伪代码 匹配到具有该url的角色放入集合
            String[] values </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> String[list.size()];
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> SecurityConfig.createList(values);
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;">没有匹配上的资源，都是登录访问</span>
        <span style="color: #0000ff;">return</span> SecurityConfig.createList(<span style="color: #800000;">"</span><span style="color: #800000;">ROLE_LOGIN</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    }

    @Override
    </span><span style="color: #0000ff;">public</span> Collection&lt;ConfigAttribute&gt;<span style="color: #000000;"> getAllConfigAttributes() {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    }

    @Override
    </span><span style="color: #0000ff;">public</span> boolean supports(Class&lt;?&gt;<span style="color: #000000;"> aClass) {
        </span><span style="color: #0000ff;">return</span> FilterInvocation.<span style="color: #0000ff;">class</span><span style="color: #000000;">.isAssignableFrom(aClass);
    }
}</span></pre>
</div>
<p>&nbsp;下面我们需要通过用户所拥有的角色和url所需角色作比对,匹配可以访问,不匹配抛出异常AccessDeniedException,这里更巧的一点是</p>
<p>我们可以通过Authentication获取用户所拥有的的角色,我们在上面实现类放入的角色集合也通过参数形式再次传了进来,我们可以循环比对当前用户是否有足够权限</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">@Component
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> UrlAccessDecisionManager implements AccessDecisionManager {
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> decide(Authentication auth, Object o, Collection&lt;ConfigAttribute&gt;<span style="color: #000000;"> cas){
        Iterator</span>&lt;ConfigAttribute&gt; iterator =<span style="color: #000000;"> cas.iterator();
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (iterator.hasNext()) {
            ConfigAttribute ca </span>=<span style="color: #000000;"> iterator.next();
            </span><span style="color: #008000;">//</span><span style="color: #008000;">当前请求需要的权限</span>
            String needRole =<span style="color: #000000;"> ca.getAttribute();
            </span><span style="color: #0000ff;">if</span> (<span style="color: #800000;">"</span><span style="color: #800000;">ROLE_LOGIN</span><span style="color: #800000;">"</span><span style="color: #000000;">.equals(needRole)) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (auth instanceof AnonymousAuthenticationToken) {
                    </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> BadCredentialsException(<span style="color: #800000;">"</span><span style="color: #800000;">未登录</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                } </span><span style="color: #0000ff;">else</span>
                    <span style="color: #0000ff;">return</span><span style="color: #000000;">;
            }
            </span><span style="color: #008000;">//</span><span style="color: #008000;">当前用户所具有的权限</span>
            Collection&lt;? extends GrantedAuthority&gt; authorities =<span style="color: #000000;"> auth.getAuthorities();
            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (GrantedAuthority authority : authorities) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (authority.getAuthority().equals(needRole)) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }
            }
        }
        </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> AccessDeniedException(<span style="color: #800000;">"</span><span style="color: #800000;">权限不足!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    }
    @Override
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> boolean supports(ConfigAttribute configAttribute) {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    @Override
    </span><span style="color: #0000ff;">public</span> boolean supports(Class&lt;?&gt;<span style="color: #000000;"> aClass) {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
}</span></pre>
</div>
<p>当我们把这两个接口自定义实现了方法之后,后面每一步的自定义处理信息,我们都可以根据业务需要去处理,比如</p>
<p>自定义身份验证处理器: 根据异常去响应会不同信息或者跳转url,其他自定义处理器同理</p>
<p>下面给大家一个处理器demo,下面自定义处理器custom**的都可以参考做不同情况处理返回值等来完成处理,前后端分离可以响应数据,不分离的可以跳转页面</p>
<div class="cnblogs_code">
<pre>  <span style="color: #0000ff;">public</span><span style="color: #000000;"> AuthenticationFailureHandler customAuthenticationFailureHandler() {
        AuthenticationFailureHandler failureHandler </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> AuthenticationFailureHandler() {
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onAuthenticationFailure(HttpServletRequest httpServletRequest,
                    HttpServletResponse resp, AuthenticationException e)
                    throws IOException, ServletException {
                resp.setContentType(</span><span style="color: #800000;">"</span><span style="color: #800000;">application/json;charset=utf-8</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                RespBean respBean </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (e instanceof BadCredentialsException
                        </span>||<span style="color: #000000;"> e instanceof UsernameNotFoundException) {
                    respBean </span>= RespBean.error(<span style="color: #800000;">"</span><span style="color: #800000;">账户名或者密码输入错误!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (e instanceof LockedException) {
                    respBean </span>= RespBean.error(<span style="color: #800000;">"</span><span style="color: #800000;">账户被锁定，请联系管理员!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (e instanceof CredentialsExpiredException) {
                    respBean </span>= RespBean.error(<span style="color: #800000;">"</span><span style="color: #800000;">密码过期，请联系管理员!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (e instanceof AccountExpiredException) {
                    respBean </span>= RespBean.error(<span style="color: #800000;">"</span><span style="color: #800000;">账户过期，请联系管理员!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (e instanceof DisabledException) {
                    respBean </span>= RespBean.error(<span style="color: #800000;">"</span><span style="color: #800000;">账户被禁用，请联系管理员!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    respBean </span>= RespBean.error(<span style="color: #800000;">"</span><span style="color: #800000;">登录失败!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
                resp.setStatus(</span><span style="color: #800080;">401</span><span style="color: #000000;">);
                ObjectMapper om </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> ObjectMapper();
                PrintWriter </span><span style="color: #0000ff;">out</span> =<span style="color: #000000;"> resp.getWriter();
                </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.write(om.writeValueAsString(respBean));
                </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.flush();
                </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.close();
            }
        };
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> failureHandler;
    }</span></pre>
</div>
<p>　　当我们把表建立好,实现上面的不同接口处理器,完成上述配置,我们就可以实现安全访问控制,至于spring security更深层级的用法,欢迎大家一起探讨!有时间我会分享一下另一个主流的安全访问控制框架 Apache shiro.其实我们会发现,所有的安全框架都是基于RBAC模型来实现的,根据框架的接口去做自定义实现来完成权限控制.</p>
</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
		</div>
		<div class="postDesc">posted @ 
<span id="post-date">2020-04-24 18:07</span>&nbsp;
<a href="https://www.cnblogs.com/zhaoletian/">蚂蚁style</a>&nbsp;
阅读(<span id="post_view_count">...</span>)&nbsp;
评论(<span id="post_comment_count">...</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=12747628" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(12747628);return false;">收藏</a></div>
	</div>
	
	
</div><!--end: topics 文章、评论容器-->
<script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 503265, cb_blogApp = 'zhaoletian', cb_blogUserGuid = 'd43b779c-afbc-4203-12aa-08d6ace5948c';
    var cb_entryId = 12747628, cb_entryCreatedDate = '2020-04-24 18:07', cb_postType = 1; 
    loadViewCount(cb_entryId);
</script><a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>

<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <script async="async" src="https://www.googletagservices.com/tag/js/gpt.js"></script>
    <script>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
    </script>
    <script>
        googletag.cmd.push(function () {
            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());
            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.enableServices();
        });
    </script>
    <div id="cnblogs_c1" class="c_ad_block">
        <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;"></div>
    </div>
    <div id="under_post_news"></div>
    <div id="cnblogs_c2" class="c_ad_block">
        <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;">
            <script>
                if (new Date() >= new Date(2018, 9, 13)) {
                    googletag.cmd.push(function () { googletag.display("div-gpt-ad-1539008685004-0"); });
                }
            </script>
        </div>
    </div>
    <div id="under_post_kb"></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
        deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);        deliverAdT2();
        deliverAdC1();
        deliverAdC2();
        loadNewsAndKb();
        loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div></div>


	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>

			<div id="calendar"><div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script></div>
			
			<DIV id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</DIV>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2020 蚂蚁style
<br /><span id="poweredby">Powered by .NET Core on Kubernetes</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    
</body>
</html>